name: Build and Sign iOS App

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-sign:
    runs-on: macos-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable

    - name: Install dependencies
      run: |
        # Install ios-deploy for device deployment (optional)
        brew install ios-deploy

        # Install aqtinstall for Qt6 iOS
        pip3 install --break-system-packages aqtinstall

        # Install Qt6 for macOS (host tools needed for cross-compilation)
        aqt install-qt mac desktop 6.8.1 clang_64 --outputdir $GITHUB_WORKSPACE/Qt

        # Install Qt6 for iOS (target platform)
        aqt install-qt mac ios 6.8.1 --outputdir $GITHUB_WORKSPACE/Qt

        # Set Qt paths
        echo "QT_HOST_PATH=$GITHUB_WORKSPACE/Qt/6.8.1/macos" >> $GITHUB_ENV
        echo "QT_PATH=$GITHUB_WORKSPACE/Qt/6.8.1/ios" >> $GITHUB_ENV

    - name: Import certificates
      env:
        P12_BASE64: ${{ secrets.IOS_CERTIFICATE_P12_BASE64 }}
        P12_PASSWORD: ${{ secrets.IOS_CERTIFICATE_PASSWORD }}
      run: |
        # Create temporary directory for certificates
        mkdir -p ~/certs

        # Decode P12 certificate from base64
        echo "$P12_BASE64" | base64 --decode > ~/certs/certificate.p12

        # Verify P12 file was created
        ls -lh ~/certs/certificate.p12
        echo "P12 file size: $(wc -c < ~/certs/certificate.p12) bytes"

        # Test P12 password with openssl first
        echo "Testing P12 file with openssl..."
        openssl pkcs12 -in ~/certs/certificate.p12 -passin "pass:$P12_PASSWORD" -noout -info || {
          echo "ERROR: Failed to read P12 with openssl"
          exit 1
        }

        # Extract certificate and key from P12 using openssl (security command doesn't support PBES2)
        echo "Extracting certificate and key with openssl..."
        openssl pkcs12 -in ~/certs/certificate.p12 -passin "pass:$P12_PASSWORD" -out ~/certs/cert-and-key.pem -nodes

        # Create temporary keychain
        KEYCHAIN_NAME="ios-build.keychain-db"
        KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

        # Create keychain
        security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
        security set-keychain-settings -lut 21600 "$KEYCHAIN_NAME"
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

        # Import extracted certificate and key
        security import ~/certs/cert-and-key.pem \
          -k "$KEYCHAIN_NAME" \
          -P "" \
          -A

        # Set key partition list
        security set-key-partition-list \
          -S apple-tool:,apple: \
          -k "$KEYCHAIN_PASSWORD" \
          "$KEYCHAIN_NAME"

        # Add to keychain search list
        security list-keychains -d user -s "$KEYCHAIN_NAME" $(security list-keychains -d user | sed s/\"//g)

        # Verify certificate is available
        security find-identity -v -p codesigning "$KEYCHAIN_NAME"

        # Store keychain password for cleanup
        echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV
        echo "KEYCHAIN_NAME=$KEYCHAIN_NAME" >> $GITHUB_ENV

    - name: Install provisioning profile
      env:
        PROVISION_BASE64: ${{ secrets.IOS_PROVISION_PROFILE_BASE64 }}
      run: |
        # Create provisioning profiles directory
        mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles

        # Decode and save provisioning profile
        echo "$PROVISION_BASE64" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision

        # Extract UUID and create proper filename
        PROFILE_UUID=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | plutil -extract UUID raw -)
        cp ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/${PROFILE_UUID}.mobileprovision

        # Save profile path for signing
        echo "PROVISION_PROFILE=~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision" >> $GITHUB_ENV

    - name: Build Qt6 iOS app with CMake
      run: |
        # Build Qt6 app with CMake
        echo "Building Qt6 iOS app with CMake..."

        # Extract bundle ID from provisioning profile
        BUNDLE_ID=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | plutil -extract Entitlements.application-identifier raw - | sed 's/^[^.]*\.//')
        echo "Extracted Bundle ID: $BUNDLE_ID"

        # Use Qt6 installed via aqt
        echo "Qt6 path: $QT_PATH"
        ls -la "$QT_PATH"

        # Create build directory
        mkdir -p build
        cd build

        # Configure with CMake for iOS using Qt6 toolchain
        cmake ../qt-app \
          -DCMAKE_PREFIX_PATH="$QT_PATH" \
          -DCMAKE_TOOLCHAIN_FILE="$QT_PATH/lib/cmake/Qt6/qt.toolchain.cmake" \
          -DCMAKE_BUILD_TYPE=Release \
          -DQT_HOST_PATH="$QT_PATH" \
          -DCMAKE_XCODE_ATTRIBUTE_DEVELOPMENT_TEAM="4D6V9Q7PN2" \
          -DCMAKE_XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY="iPhone Developer" \
          -DCMAKE_XCODE_ATTRIBUTE_PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
          -G Xcode

        # Build with xcodebuild
        xcodebuild \
          -project HelloWorldQt6.xcodeproj \
          -scheme HelloWorldQt6 \
          -configuration Release \
          -sdk iphoneos \
          -arch arm64 \
          CODE_SIGN_IDENTITY="" \
          CODE_SIGNING_REQUIRED=NO \
          CODE_SIGNING_ALLOWED=NO

        # Find the built app
        APP_BUNDLE_PATH=$(find . -name "HelloWorldQt6.app" -type d | head -1)
        echo "Built app at: $APP_BUNDLE_PATH"

        # Update Info.plist with correct bundle ID
        /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier $BUNDLE_ID" "$APP_BUNDLE_PATH/Info.plist"

        cd ..
        echo "APP_BUNDLE_PATH=build/$APP_BUNDLE_PATH" >> $GITHUB_ENV
        echo "BUNDLE_ID=$BUNDLE_ID" >> $GITHUB_ENV

    - name: Create entitlements file
      run: |
        # Extract entitlements from provisioning profile
        security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | plutil -extract Entitlements xml1 -o build/Entitlements.plist -

        echo "ENTITLEMENTS_PATH=build/Entitlements.plist" >> $GITHUB_ENV

    - name: Sign iOS app
      run: |
        # Get signing identity
        SIGNING_IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_NAME" | grep -E "^[[:space:]]*1\)" | grep -oE "[A-F0-9]{40}" | head -1)
        echo "Signing with identity: $SIGNING_IDENTITY"

        # Embed provisioning profile
        cp ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision "$APP_BUNDLE_PATH/embedded.mobileprovision"

        # Remove extended attributes
        xattr -cr "$APP_BUNDLE_PATH"

        # Sign the app
        codesign --force \
          --sign "$SIGNING_IDENTITY" \
          --entitlements "$ENTITLEMENTS_PATH" \
          --timestamp=none \
          --verbose \
          "$APP_BUNDLE_PATH"

        # Verify signature
        codesign --verify --verbose "$APP_BUNDLE_PATH"
        codesign -dvvv "$APP_BUNDLE_PATH"

    - name: Create IPA
      run: |
        # Create output directory
        mkdir -p output

        # Create Payload directory
        mkdir -p output/Payload

        # Copy signed app
        cp -R "$APP_BUNDLE_PATH" output/Payload/

        # Create IPA
        (cd output && zip -qr HelloWorld.ipa Payload)

        # Cleanup
        rm -rf output/Payload

        echo "IPA created at: output/HelloWorld.ipa"

    - name: Upload signed IPA
      uses: actions/upload-artifact@v4
      with:
        name: signed-ios-app
        path: output/HelloWorld.ipa
        retention-days: 30

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: |
          ${{ env.APP_BUNDLE_PATH }}
          build/Entitlements.plist
        retention-days: 7

    - name: Cleanup
      if: always()
      run: |
        # Delete temporary keychain
        if [ -n "$KEYCHAIN_NAME" ]; then
          security delete-keychain "$KEYCHAIN_NAME" || true
        fi

        # Remove certificates
        rm -rf ~/certs
